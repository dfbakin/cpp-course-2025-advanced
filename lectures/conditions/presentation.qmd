---
title: "Условия, ветвление, отладка"
author: Denis Bakin
format: 
  beamer:
    pdf-engine: xelatex
    aspectratio: 169
    fontsize: 9pt
    section-titles: false
    incremental: false
    include-in-header: ../../files/presentation_header.tex
lang: ru
---

---

# Представление целых чисел в памяти компьютера
## Степени двойки

::: {.incremental}
- Удобно запоминать степени 2 в двоичной системе
- $2^n = ?$
- $2^n = 1 \underbrace{0 \dots 0}_n$
- $2^n - 1 = ?$
- $2^n - 1 = \underbrace{1 \dots 1}_n$
:::

Примеры: $255$, $1023$, $2048$, $8$.

---

# Представление целых чисел в памяти компьютера
## Sign-magnitude

- Первый бит — знак
- Остальные биты — модуль
- Арифметика неудобна для компьютера
- Пример: $-6$ в 4-битном формате → `1110`

| Бинарное значение | Sign-magnitude | Беззнаковое |
|-------------------|---------------|-------------|
| $00000000$ | $0$   | $0$   |
| $00000001$ | $1$   | $1$   |
| $\ldots$   | $\ldots$ | $\ldots$ |
| $01111111$ | $127$ | $127$ |
| $10000000$ | $-0$  | $128$ |
| $10000001$ | $-1$  | $129$ |
| $\ldots$   | $\ldots$ | $\ldots$ |
| $11111111$ | $-127$ | $255$ |


---

# Двоично-дополнительный код
## Преобразование

- Универсальное представление отрицательных чисел
- Алгоритм:
  1. Записать модуль в двоичной системе
  2. Инвертировать все биты
  3. Прибавить 1
- Пример: $-6$ в 4-битном формате → `1010`

---

# Двоично-дополнительный код
## Проверка примера $-6$

| Бит | $1$ | $0$ | $1$ | $0$ |
|-----|-----|-----|-----|-----|
| Значение | $-8$ | $4$ | $2$ | $1$ |

$1010 = -8 + 2 = -6$

То есть первый бит отвечает за $-2^{n-1}$, а остальные биты — за положительные степени двойки.

---

# Двоично-дополнительный код
## Таблица значений

| Биты | Десятичное значение |
|------|---------------------|
| $0000$ | $0$  |
| $0001$ | $1$  |
| $0010$ | $2$  |
| $\ldots$ | $\ldots$ |
| $0111$ | $7$  |
| $1000$ | $-8$ |
| $1001$ | $-7$ |
| $\ldots$ | $\ldots$ |
| $1110$ | $-2$ |
| $1111$ | $-1$ |

---

# Двоично-дополнительный код
## Преимущества

- Нет отдельной логики для знака
- Арифметика идентична беззнаковой
- Переполнение → "зацикливание"

| Биты         | Десятичное значение | Комментарий                                                    |
|--------------|---------------------|----------------------------------------------------------------|
| $10000000$   | $-128$              |                                                                |
| $10000001$   | $-127$              |                                                                |
| $\ldots$     | $\ldots$            |                                                                |
| $11111111$   | $-1$                | $11111111_2 + 1_2 = 100000000_2$. Записываем 8 правых бит      |
| $00000000$   | $0$                 |                                                                |
| $00000001$   | $1$                 |                                                                |
| $\ldots$     | $\ldots$            |                                                                |
| $01111111$   | $127$               |                                                                |
| $10000000$   | $-128$              | "Зацикливание", то есть произошло "переполнение", "overflow"   |
| $\ldots$     | $\ldots$            |                                                                |

---

# Переполнение целых типов

- Слишком большое число → берутся правые биты
- По сути: остаток при делении на $2^{\text{размер типа}}$
- Ошибки не возникает — программа продолжает выполнение

```C++
#include <iostream>

int main() {
    unsigned char c_1 = 0;
    c_1 -= 1; // underflow
    std::cout << (int)c_1 << '\n'; // 255

    c_1 = 300;
    std::cout << (int)c_1 << '\n'; // 44
}
```

---

# Условия

## Логические операции

- `!A` — отрицание (НЕ)
- `A && B` — конъюнкция (И)
- `A || B` — дизъюнкция (ИЛИ)

| $A$ | $\lnot A$ |
| ----- | ----------- |
| 0     | 1           |
| 1     | 0           |

---

# Условия

## Таблицы истинности

| $A$ | $B$ | $A \land B$ |
| ----- | ----- | ------------- |
| 0     | 0     | 0             |
| 0     | 1     | 0             |
| 1     | 0     | 0             |
| 1     | 1     | 1             |

| $A$ | $B$ | $A \lor B$ |
| ----- | ----- | ------------ |
| 0     | 0     | 0            |
| 0     | 1     | 1            |
| 1     | 0     | 1            |
| 1     | 1     | 1            |

---

# Условия

## Синтаксис if-else

```C++
if (<cond>) {
    // выполняется если условие истинно
} else {
    // выполняется если условие ложно
}
```

---

# Условия

## Пример

```C++
#include <iostream>
#include <cmath>

int main() {
    int age;
    std::cin >> age;
    if (age > 12) {
        printf("You are %d years old, so, you're too old for this cartoon\n", age);
    } else {
        printf("You are %d years old, so, you're young enough for this cartoon. Enjoy!\n", age);
    }
}
```

---

# Условия

## Множественные ветвления

```C++
if (condition1) {
    // ...
} else if (condition2) {
    // ...
} else {
    // ...
}
```

---

# Условия
## Пример: билет в кино

- Условие для клиента: номер не делится на 6 и оканчивается четной цифрой
- Сотрудники: номера < 10
- Директор: билет 777

---

# Условия
## Пример: билет в кино

- Условие для клиента: номер не делится на 6 и оканчивается четной цифрой
- Сотрудники: номера < 10
- Директор: билет 777

```C++
#include <iostream>

int main() {
    int ticket_id;
    std::cin >> ticket_id;
    if (ticket_id % 6 != 0 && (ticket_id % 10) % 2 == 0) {
        printf("Enjoy the movie, customer!\n");
    } else if (ticket_id >= 0 && ticket_id < 10) {
        printf("Hi, employee\n");
    } else if (ticket_id == 777) {
        printf("Hello, CEO!\n");
    } else {
        printf("Invalid ticket ID!\n");
    }
}
```

---

# Условия

## С числами с плавающей точкой

- Прямое сравнение `==` может быть неверным
- Использовать сравнение с погрешностью

```C++
#include <iostream>
#include <algorithm>

int main() {
    float number;
    std::cin >> number;

    if (std::abs(number - 3.0) < 0.000001) {
        std::cout << "you have entered 3.0\n";
    }
}
```

---

# Условия

## Switch-case

- Удобен для проверки на равенство множеству значений
- Работает только с элементарными типами (числа, символы)

```C++
switch (operation) {
    case '+':
        result = a + b;
        break;
    case '-':
        result = a - b;
        break;
    default:
        result = 0;
}
```

---

# Условия

## Пример калькулятора

```C++
#include <cstdint>
#include <iostream>

int main() {
    int64_t a, b;
    char operation;
    std::cin >> a >> operation >> b;

    int64_t result;
    switch (operation) {
        case '+': result = a + b; break;
        case '-': result = a - b; break;
        case '*': result = a * b; break;
        case '/': result = a / b; break;
        case '%': result = a % b; break;
        default: result = 0;
    }

    std::cout << result << "\n";
}
```

---

# Условия
## Геометрическая задача

![Задача 112166 на использование условий](/resources/images/informatics_problem_112166.png){ width=70% }

Условие области:

::: {.incremental}
- $y \le \sin(x)$
- $y \le 0.5$
- $y \ge 0$
- $x \ge 0$
- $x \le \pi$
:::

---

# Условия
## Решение задачи

```C++
#include <iostream>
#include <cmath>

int main() {
    float x, y;
    std::cin >> x >> y;
    if (y <= std::sin(x) && y >= 0 && y <= 0.5) {
        printf("YES\n");
    } else {
        printf("NO\n");
    }
}
```

---

# Отладка программ
## Основные методы

- Разбор случаев "на бумаге"
- Трассировка (дополнительный вывод)
- Использование отладчика

---

# Отладка программ

## Отладчик

- Breakpoint (точка останова)
- Окно переменных
- Набор команд: Continue, Step over, Step into, Step out, Restart, Stop

![Breakpoint и выделение строки при остановке](/resources/images/debugger_breakpoint.png)

---

# Отладка программ

## Пример окна переменных

![Окно с переменными](/resources/images/debugger_variables_tab.png)


# Представление чисел с плавающей точкой
## Формат IEEE 754 (float)

- 32 бита:  
  - 1 бит — знак  
  - 8 бит — экспонента  
  - 23 бита — мантисса  

$\underbrace{1 \text{ bit}}_{\text{sign}}
\underbrace{8 \text{ bit}}_{\text{exp}}
\underbrace{23 \text{ bit}}_{\text{mantissa}}$

---

# Представление чисел с плавающей точкой
## Компоненты

- `sign`: 0 — положительное, 1 — отрицательное  
- `exp`: показатель степени, хранится со смещением $127$  
- `mantissa`: значащие биты дробной части  

---

# Представление чисел с плавающей точкой
## Интерпретация

- $0 \le exp \le 254$: нормализованное число  
  $(−1)^{sign} \times 2^{exp−127} \times 1.[mantissa]$  
- $exp = 0$: денормализованное число  
  $(−1)^{sign} \times 2^{−126} \times 0.[mantissa]$  
- $exp = 255, mantissa = 0$: $\pm \infty$  
- $exp = 255, mantissa \ne 0$: `NaN` ("не число")  

---

# Представление чисел с плавающей точкой
## Интересный факт

- Чем ближе число к нулю → тем плотнее значения  
- При росте экспоненты шаг между числами увеличивается  
- Денормализованные числа: равномерный шаг  
- Нормализованные: шаг удваивается при увеличении exp  

![Распределение чисел с плавающей точкой](/resources/images/float_normalized.png)

---

# Представление чисел с плавающей точкой
## Тип double

- Аналогично float, но 64 бита  
  - 1 бит — знак  
  - 11 бит — экспонента  
  - 52 бита — мантисса  
- Более высокая точность  
- Более широкий диапазон значений  

---

# Представление чисел с плавающей точкой
## Вопросы для размышления

- Почему нельзя точно записать любое рациональное число?  
- Как доступная точность зависит от модуля числа?  
- Сколько есть способов записать $0$?  
- Как перемножить два `float` на уровне битов? 
